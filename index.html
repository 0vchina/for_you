<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebAR Fixed Direction Model</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
<div id="debugInfo" style="
  position: absolute;
  top: 10px;
  left: 10px;
  padding: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: yellow;
  font-family: monospace;
  font-size: 14px;
  white-space: pre-line;
  z-index: 999;
">
  GPS: инициализация...
</div>

<a-scene vr-mode-ui="enabled: false" embedded arjs="sourceType: webcam; trackingMethod: best;">
  <a-camera></a-camera>

  <a-entity
    id="targetModel"
    gltf-model="model.glb"
    scale="3 3 3"
    rotation="0 180 0"
    visible="false"
  ></a-entity>
</a-scene>

<script>
  const debugInfo = document.getElementById('debugInfo');
  const model = document.getElementById('targetModel');

  const benchLat = 52.1534551;
  const benchLon = 26.1951000;
  const benchBearing = 90; // направление сидения: 90° = восток
  const appearDistance = 10.0; // порог активации увеличен до 10 метров
  const modelDistance = 15.0;  // модель появляется в 5 м вперёд от лавочки
  const maxAccuracy = 20.0;   // GPS должен быть точнее 20 м

  const positionBuffer = [];
  const bufferSize = 5;
  let modelLocked = false;

  function computeDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = deg => deg * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function computeOffset(lat1, lon1, lat2, lon2) {
    const R = 6378137;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const x = dLon * R * Math.cos(lat1 * Math.PI / 180);
    const z = dLat * R;
    return { x, z: -z };
  }

  function getSmoothedPosition(newPos) {
    positionBuffer.push(newPos);
    if (positionBuffer.length > bufferSize) positionBuffer.shift();

    const avg = positionBuffer.reduce(
      (acc, p) => ({
        x: acc.x + p.x,
        z: acc.z + p.z
      }),
      { x: 0, z: 0 }
    );

    return {
      x: avg.x / positionBuffer.length,
      z: avg.z / positionBuffer.length
    };
  }

  function computeDestination(lat, lon, distance, bearingDeg) {
    const R = 6378137;
    const bearing = bearingDeg * Math.PI / 180;
    const latRad = lat * Math.PI / 180;
    const lonRad = lon * Math.PI / 180;

    const newLat = Math.asin(
      Math.sin(latRad) * Math.cos(distance / R) +
      Math.cos(latRad) * Math.sin(distance / R) * Math.cos(bearing)
    );

    const newLon = lonRad + Math.atan2(
      Math.sin(bearing) * Math.sin(distance / R) * Math.cos(latRad),
      Math.cos(distance / R) - Math.sin(latRad) * Math.sin(newLat)
    );

    return {
      lat: newLat * 180 / Math.PI,
      lon: newLon * 180 / Math.PI
    };
  }

  navigator.geolocation.watchPosition(
    pos => {
      if (modelLocked) return;

      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const accuracy = pos.coords.accuracy;

      if (accuracy > maxAccuracy) {
        debugInfo.innerText =
          `Ваши координаты:\n${lat.toFixed(6)}, ${lon.toFixed(6)}\n` +
          `Точность слишком низкая: ${accuracy.toFixed(1)} м\n` +
          'Ожидание сигнала GPS...';
        return;
      }

      const distance = computeDistance(lat, lon, benchLat, benchLon);

      debugInfo.innerText =
        `Ваши координаты:\n${lat.toFixed(6)}, ${lon.toFixed(6)}\n` +
        `Точность: ${accuracy.toFixed(1)} м\n` +
        `До лавочки: ${distance.toFixed(1)} м\n` +
        'Ожидание...';

      if (distance <= appearDistance) {
        const target = computeDestination(benchLat, benchLon, modelDistance, benchBearing);
        const offset = computeOffset(lat, lon, target.lat, target.lon);
        const smooth = getSmoothedPosition(offset);
        model.setAttribute('position', `${smooth.x} 0 ${smooth.z}`);
        model.setAttribute('visible', true);

        if (positionBuffer.length >= bufferSize) {
          modelLocked = true;
          debugInfo.innerText += '\nМодель зафиксирована!';
          console.log("Модель установлена по направлению лавочки:", smooth);
        }
      } else {
        model.setAttribute('visible', false);
        positionBuffer.length = 0;
      }
    },
    err => {
      console.error('Ошибка GPS:', err);
      debugInfo.innerText = `Ошибка GPS:\n${err.message}`;
    },
    { enableHighAccuracy: true }
  );
</script>
</body>
</html>
